# 对于包含关系

当B类包含A类时，即A类是B类的成员时，如下代码

```cpp
class A
{};

class B
{
private:
    A a;
    int data;
}
```

若A类与B类拷贝构造函数都没有显示给出，系统将合成一个拷贝构造函数，执行按位拷贝，符合常规逻辑

>按位拷贝，用类似memcpy的内存拷贝函数，从源内存地址的起始位置开始以位为单位拷贝若干个字节到目标内存地址中

如果A类对象成员显示给出了缺省的拷贝构造，那么合成的拷贝构造函数在构造这个成员时会调用这个成员显示给出的拷贝构造函数，其他没显示给出拷贝构造函数的成员继续按位去拷贝

合成的赋值语句同理

即B类对象的行为要和成员对象（a）的行为保持一致

# 对于继承关系

```cpp
class A
{};

class B:public A
{};
```

若A类与B类拷贝构造函数都没有显示给出，系统将合成一个拷贝构造函数，执行按位拷贝，符合常规逻辑

如果父类A显示给出了缺省的拷贝构造，那么子类B合成的拷贝构造在构造隐藏父类成员时会去调动父类显示给出的拷贝构造。（父能约束子）

如果父类A没显示给出拷贝构造，而子类B显示给出了拷贝构造函数，那么合成的拷贝构造函数就会按B给出的拷贝构造函数去执行，没有在B显示给出的拷贝函数中体现的成员**会去执行缺省构造函数去构造，而不会执行按位拷贝**，这是要着重注意的（子不能约束父），例如下代码：

```cpp
class A
{
private:
	int a_val;
public:
	A(int x = 0) : a_val(x) { cout << "construct A" << endl; }
	~A() { cout << "deconstruct A" << endl; }
};

class B :public A
{
private:
	int b_val;
public:
	B(int x = 0) : b_val(x),A(x+10) { cout << "construct B" << endl; }
	B(const B & b) :b_val(b.b_val)
	{
		cout << "copy construct B" << endl;
	}
	~B() { cout << "deconstruct B" << endl; }
};

int main()
{
	B  b1(10);

	B b2(b1);
	
}
```

 <img src="img/C++%EF%BC%9A%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0.img/image-20210111105656305.png" alt="image-20210111105656305" style="zoom:50%;" />

 <img src="img/C++%EF%BC%9A%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0.img/image-20210111105751179.png" alt="image-20210111105751179" style="zoom:50%;" />

b1的成员A的a_val值为10，b_val值为20，用b1去拷贝构造b2时候，调用B类显示给出的拷贝构造函数，先执行该拷贝构造函数参数列表，由于参数列表没有对隐藏父对象A的说明，所以去调动A的缺省构造函数，a_val值为0，接着给b_val值赋为b1.val即10，然后进入该拷贝构造函数函数体打印出"copy construct B"

由于B类显示给出的拷贝构造函数只对b_val进行了说明，而并没有说明隐藏父对象A应该怎样构造，所以A调动的是缺省构造函数，并不是按位拷贝

> 父能约束子
>
> 父类有构造，将约束子类型也有构造；父类有析构，将会约束子类型也有析构；父类有拷贝构造，将会约束子类型也有拷贝构造
>
> 子不能约束父
>
> 子类型有拷贝构造，而父类没有拷贝构造，子类型不能约束父类型也去生成拷贝构造
>
> 可以向下约束，不可以向上约束

![image-20210111113019382](img/C++%EF%BC%9A%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0.img/image-20210111113019382.png)

value是obj的私有成员，这怎么可以直接访问呢？