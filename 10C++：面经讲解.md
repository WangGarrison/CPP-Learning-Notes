## **C++this指针干什么用的**

一个类型定义了很多对象，每个对象都有各自的私有成员变量，但是它们都是共用一套成员方法的，在成员方法中怎么区别它操纵的到底是哪个对象的数据呢？这就是this指针用处：==通过this指针来区分操纵的是哪个具体对象的数据==，t.test=>test(&t)

当对象调用方法时，实际上把对象的地址当作实参传入，被this形参变量接收，然后在方法中，所有成员的访问，前面默认都会添加this->  

## C++的new和delete，什么时候用new[]申请，可以用delete释放？

new和delete本质上是运算符重载：operator new和operator delete

new ptr[]对应delete []ptr;

new：分配内存，构建对象；delete：调用析构函数，释放内存

如果是自定义类型，而且提供了析构函数，那么用new[]就一定需要匹配delete []ptr，其他情况==（内置类型/没提供析构函数）用delete/delete[]/free释放都可以==，但是最好按规定对应着写

> 类有真实析构函数时，定义该类一组对象时，首地址上面会多产生四个字节代表这组对象的个数，所以要用delete[]
>
> 类没有真实的析构函数时，定义该类一组对象时，首地址上面并不会多产生四字节指示个数，因为没有析构所以就没必要记录这组对象的个数，又因为没有这4个字节，所以用delete或delete[]或free释放都可以

## C++的static关键字的作用

==从面向过程来说，static可以修饰全局变量、函数、局部变量==。static修饰的全局变量和函数链接属性会变成内部的，即本来整个工程里的文件都可见，但是static加上就只有本文件可见了（从文件elf结构来说：被static修饰以后，在符号表中，符号的作用域就从global变成local了）；

static修饰局部变量的话，变量内存就放在数据段了，.data/.bss，有初值且不为0在.data段，否则在.bss段，非静态的局部变量本身不产生符号的，在栈上通过ebp - 偏移量来访问，但是变成静态的就要产生符号了，符号作用域是local

==从面向对象角度来说，static可以修饰成员变量，成员方法（不再产生this指针）==。加上static的成员变量/成员方法就从对象私有的变成共享的了，成员方法也就不再产生this指针了，也就不需要通过对象来调用了，直接用类作用域就可以调

## C++的继承  

类和类 继承a kind of...还有组合a part of...

- ==代码的复用==

- 通过继承，在基类里面给所有派生类可以保留统一的纯虚函数接口，等待派生类进行重写，通过使
  用多态，可以==通过基类的指针访问不同派生类对象的同名覆盖方法==。  
- 两个互为继承关系的类，基类和派生类的同名方法（返回值，函数名，参数列表都相同），而且基类的该方法是virtual虚函数，那么这两个方法之间互为覆盖的关系，否则是隐藏；基类和派生类之间同
  名方法可以覆盖，是C++多态的必备条件  
- C++是支持多重继承的，但是典型的菱形继承等会发生问题，导致派生类拥有间接基类多份成员变量，和实际情况不符。解决这个问题的办法是引入虚继承。  

## C++的多态，空间配置器，vector 和list的区别，map，多重map？  

多态：展现出来多种形态

- 静多态：编译时期的多态，==函数重载和模板==（模板推演是在编译阶段）
- 动多态：运行时期的多态，==虚函数 指针/引用指向派生类对象==  

空间配置器allocator：给容器使用的，主要作用==把内存开辟和对象构造分开==，把对象析构和内存释放分开  

vector和list的区别：数组和链表的区别，==vector适用于随机访问多，list适合增加删除多==  

==map（不允许key重复的）：映射表[key-value]，底层实现红黑树，multimap（允许key重复的）==  

红黑树：5个性质，插入3种情况（最多旋转2次），删除（最多旋转3次）4种情况  

- 每个节点都要有颜色
- 根节点必须是黑色
- 叶子结点必须是黑色
- 从根节点到叶子结点的路径上不允许出现连续红色节点
- 不允许出现两个连续的红色节点

## C++如何防止内存泄露？智能指针详述？  

内存泄漏：分配的堆内存（没有名字，只能用指针来指向）没有释放，也再没有机会释放了  

```cpp
int *p = new int[10000];
// unique_ptr pre(new int[100000]);auto_ptr/scoped_ptr/unique_ptr shared_ptr/weak_ptr
if(xxx)
	return; // 运行抛异常了，提前return了，后面的delete没有运行到，内存泄漏
delete []p;
```

防止内存泄漏：==使用智能指针（RAII：栈上对象出作用域自动析构）==

## C++如何调用C语言函数接口  

==extern "C"==

C++有定义__cpluscplus，如果是C++就会进红框，如果是C就不会进红框

![image-20210305104237292](img/C++%EF%BC%9A%E9%9D%A2%E7%BB%8F%E8%AE%B2%E8%A7%A3.img/image-20210305104237292.png)

## C++什么时候会出现访问越界？ 

访问的内存超过分配给我们的内存

- 访问数组元素越界了

- vector容器访问 vector< int > vec; vec[2]; //空容器，直接访问2号元素，越界

- string str; str[2]

- array

- 字符串处理，==没有添加'\0'字符，导致访问字符串的时候越界了==

- 使用类型强转，让一个大类型（派生类）的指针指向一块小内存（基类对象）了，然后指针解引用，
  访问的内存就越界了  

## C++中类的初始化列表

可以指定对象成员变量的初始化方式，尤其是指定成员对象的构造方式  

## C和C++的区别？C和C++的内存分布有什么区别？  

1.引用

2.函数重载

3.new/delete malloc/free

4.const, inline,带默认值参数的函数

5.模板

6.类和对象 OOP =》 设计模式了

7.STL

8.异常 智能指针 运算符重载

9.内存分布没什么区别：都是：

- user space (用户空间3G)：reserve（不可访问区） .text .rodata .data .bss heap stack 命令行参数和环境变量
-  kernal space(内核空间1G)：ZONE_DMA ZONE_NORMAL(.text .rodata .data. bss. heap stack) ZONE_HIGHMEM  

## int* const p和const int *p区别

const==修饰直接右边，基本类型透明==，int* const p，p不可变，const int\*p，*p不可变

## malloc和new区别？  

1.malloc按字节开辟内存 new底层也是通过malloc开辟内存，但是还可以提供初始化  

2.malloc开辟内存失败 nullptr new开辟失败，抛出bad_alloc类型的异常  

3.malloc C的库函数 operator new  

4.malloc 单个 数组 new int(10); new int[20] ();  //带小括号会初始化为0，括号里不能写数字

## map&set容器的实现原理？  

set集合，只存储key；map映射表，存储[key,value]键值对，底层数据结构都是红黑树	

## shared_ptr引用计数存在哪里  

堆上分配的  

## STL、map底层、deque底层、vector里的empty()和size()的区别、函数对象？  

STL

- 标准容器 =》 顺序容器（vector,deque,list），容器适配器(stack,queue,priority_queue)，关联容器
  (有序和无序)

- 近容器 数组，string，bitset

- 迭代器

- 泛型算法

map底层：红黑树

deque底层：动态开辟的二维数组

empty()和size()区别：empty判空，size返回元素个数（last-first）

 <img src="img/C++%EF%BC%9A%E9%9D%A2%E7%BB%8F%E8%AE%B2%E8%A7%A3.img/image-20210305114449130.png" alt="image-20210305114449130" style="zoom:50%;" />

函数对象 operator() test(); test.operator()();

函数对象一般使用在泛型算法当中 sort find_if priority_queue set map  

## STL中的迭代器失效的问题

迭代器是不允许一边读一遍修改的

当通过迭代器插入一个元素，所有迭代器就都失效了

当通过迭代器删除一个元素，当前删除位置都后面所有的元素的迭代器就都失效了

当通过迭代器更新容器元素以后，要及时对迭代器进行更新， insert / erase方法都会返回新位置的迭
代器  

## STL中哪些底层由红黑树实现？  

set multiset map multimap  

## struct和class的区别？  

- 定义类的时候的区别，struct访问性默认公有，class访问性默认私有
- 继承时，派生类 struct B : A（struct默认是公有继承） class B : A （class默认私有继承）
- struct定义的空结构体在C里是0，struct定义的空类在C++里是1
- struct定义的可以这样初始化：C++11 struct Data { int ma, int mb}   Data data = {10, 20};  ，class定义的不能这样初始化
- class在template< class T >还可以定义模板类型参数  

## 各容器底层实现

- vector底层：可扩容的数组
- deque底层：动态开辟的二维数组
- list底层：双向循环链表
- stack底层：deque
- queue底层：deque
- priority_queue底层：vector
- set/map底层：红黑树
- unordered_set/unordered_map底层：链式哈希表

## 初始化全局变量和未初始化全局变量有什么区别？  

.data(初始化，且初始值不为0) .bss（未初始化，初始化为0）  

## 堆和栈的区别？  

堆内存的大小 >> 栈内存 malloc/new free/delete 函数的运行，函数的局部变量

堆的内存增长方向是从：低地址 =》 高地址

栈的内存增长方向是从：高地址 =》 低地址  

## 构造函数和析构函数可不可以是虚函数

构造函数不能是虚函数（创建一个对象，势必要知道对象的具体类型）

析构函数可以  

Base *p = new Derive(); 把基类的析构函数是现成虚析构函数

delete p; // 对析构函数的调用进行动态绑定 ~Base() ~Derive()  

> 虚函数必须把函数地址放在虚函数表里面，虚函数表是通过虚函数指针来访问的，函数指针在堆栈里面。虚函数就是基类指针指向一个派生类对象，调用这个方法的时候，调用的就不是基类的，而是派生类的。
>
> 调用派生类构造函数的时候，要先构造基类，如果基类构造函数定义为虚函数，难道要让它再去调用派生类的构造函数吗，这样就会无限递归调用下去。事实上，构造函数压根就不可以定义为虚函数，因为构造函数调用的时候，对象还不存在，对象不存在就没有虚函数指针，没有虚函数指针也就访问不了虚函数表 

##  宏和内联函数的区别？

**处理时机不同**

- 宏：是在预编译阶段进行处理的（字符串替换）

- 内联：是在编译阶段处理的（在函数调用点，通过函数的实参把函数代码直接展开调用，节省了函数的调用开销）

**是否可以调试**

- 宏：没有办法调试
- 内联：inline函数可以调试（debug版本下内联函数就和普通函数一样，有标准的函数调用过程）

**定义上**

- #define 可以定义常量，代码块，函数块 

- inline只是修饰函数

## 局部变量存在哪里？  

stack ebp指针偏移来访问的，不产生符号，局部变量产生的是指令，存在.text

int a = 10; => mov dword ptr[ebp-4], 0Ah 

## 拷贝构造函数，为什么传引用而不传值？  

防止递归引用。

当 一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数生成一个复本。如果类A的拷贝构造函数是以值方式传递一个类A对象作为参数的话，当 需要调用类A的拷贝构造函数时，需要以值方式传进一个A的对象作为实参；而以值方式传递需要调用类A的拷贝构造函数；结果就是调用类A的拷贝构造函数导 致又一次调用类A的拷贝构造函数，这就是一个无限递归

VS里面传值会直接产生编译错误

 <img src="img/C++%EF%BC%9A%E9%9D%A2%E7%BB%8F%E8%AE%B2%E8%A7%A3.img/image-20210311192005011.png" alt="image-20210311192005011" style="zoom:50%;" />

## 内联函数和普通函数的区别（从反汇编角度来回答）？  

核心：函数的调用开销！  

普通函数调用过程（开销）：

- 压实参：push ebp
- esp赋给ebp：move ebp, esp 
- 开辟栈帧：sub esp, 4Ch
- windows下初始化栈：rep stos 0xCCCCCCCC(windows) GCC(gcc/g++)：分配完栈帧， 不做任何栈初始化动作  
- 释放栈：move esp, ebp    pop ebp    ret

 内联函数不需要上述开销，当执行到内联函数的时候，将此函数展开，如果程序中有N次调用了内联函数则会有N次展开函数代码

## 如何实现一个不可以被继承的类？  

派生类的初始化过程：基类构造 =》 派生类构造，所以**基类的构造函数私有化**就会使得该基类不可以被继承  

## 什么是纯虚函数？为什么要有纯虚函数？虚函数表放在哪里的？  

纯虚函数：virtual void func() = 0;  抽象类（不能实例化对象的，可以定义指针和引用）  

纯虚函数一般定义在基类里面，基类不代表任务实体，它的主要作用之一就是**给所有的派生类保留统一的纯虚函数接口，让派生类进行重写，方便的使用多态机制**。因为基类不需要实例化，它的方法也就不知道该怎么去实现！  

虚函数表 在 编译阶段产生的！ 运行时，加载到.rodata段  

## 手写单例模式  

```cpp
std::mutex mtx;
//懒汉式单例模式
class Singleton
{
private:
	static Singleton *volatile instance;
private:
	Singleton(){}
	Singleton(const Singleton &) = delete;
	Singleton& operator=(const Singleton&) = delete;
public:
	Singleton* getInstance()
	{
		if (instance == nullptr)
		{
			lock_guard<mutex> guard(mtx);
			if (instance == nullptr)
			{
				instance = new Singleton;
			}
		}
		return instance;
	}
};
Singleton*volatile Singleton::instance = nullptr;
```

## const，const与static的区别？  

const定义的叫常量，它的编译方式是：编译过程中，把出现常量名字的地方，用常量的值进行==替换==  

const还可以定义常成员方法（方法后面加上const），相当于*this前面加上了const（Test *this => const Test *this）普通对象和常对象就都可以调用了！  

**const和static的区别**  

面向过程：

- const修饰：全局变量，局部变量，形参变量 

- static修饰：全局变量，局部变量  
- const：不能修饰（面向过程）函数 static：可以修饰函数  

面向对象：

- const：常方法/成员变量 Test *this => const Test *this 依赖对象  
- static：静态方法/成员变量，static修饰的类内方法没有this指针了， 不依赖于对象 通过类作用域访问  

## 四种类型转换

- const_cast : 去掉（指针或者引用）常量属性的一个类型转换
- static_cast :  提供编译器认为安全的类型转换（没有任何联系的类型之间的转换就被否定了）
- reinterpret_cast : 类似于C风格的强制类型转换
- dynamic_cast : 主要用在继承结构中，可以支持RTTI类型识别的上下转换

## 详细解释deque的底层原理

双端队列：底层是动态开辟的二维数组

#define MAP_SIZE 2  //一维的初始大小

#define QUE_SIZE(T) 4096/sizeof(T)  //第二维数组默认开辟的大小

双端队列，两端都可以插入删除O(1)

扩容： 把第一维数组按照2倍的方式进行扩容 2-4-8-16，扩容以后，会把原来的第二维的数组，从新一维数组的oldsize/2开始存放

deque内存利用率好，它是分段连续的，刚开始就有一段内存可供使用，不像vecotr整块都是连续的，vectir扩容是0-1-2-4-8

## 虚函数、多态

一个类如果有虚函数，在编译阶段就会给该类产生一张虚函数表，运行的时候虚函数表加载到.rodata段

用指针或者引用调用虚函数的时候，首先通过指针访问对象的头四个字节vfptr，再去相应的vftable中取虚函数的地址，进行动态绑定调用

多态：基类指针指向不同的派生类对象，然后调用不同派生类对象的同名覆盖方法，基类指针指向谁，就可以调用谁的方法，多态使得设计函数接口的时候，可以都使用基类的指针或者引用来接收不同的派生类对象

## 异常机制

```cpp
try
{
    可能会抛出异常(throw)的代码
}
catch(const string &str)
{
    捕获相应异常类型对象，进行处理，完成后，代码继续向下运行
}
```

当前函数抛出异常，如果在当前函数栈帧上没有找到相应的catch块处理，就会把异常抛给调用方函数，异常会一层一层往回抛，直到某个调用点可以处理异常，如果抛到主函数都不能处理异常，就抛给操作系统，操作系统杀死进程

异常机制好处：可以把代码中所有的异常抛到统一的地方进行处理

## 早绑定和晚绑定

早绑定（静态绑定）：普通函数的调用，用对象调用虚函数，编译阶段就知道调用哪个函数

晚绑定（动态绑定）：用指针或引用调用虚函数的时候，都是动态绑定，在编译阶段是不知道调用的具体的函数的，只有在运行阶段通过p->vfptr->vftable->virtual addr =>call eax才知道调用的具体函数

## 指针和引用的区别

引用是一种更安全的指针

- 指针有自己的一块空间，而引用只是一个别名  
- 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小
- 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用 
- 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象  

- 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变  
- 指针可以有多级指针（**p），而引用只有一级

## 智能指针交叉引用问题怎么解决？

==定义对象的时候用强智能指针shared_ptr，而引用对象的时候用弱智能指针weak_ptr==

当通过weak_ptr访问对象成员时，需要先调用wak_ptr的lock提升方法，把weak_ptr提升成shared_ptr，再进行对象成员调用

## 重载的底层实现

重载：==C++生成函数符号是依赖函数名字+参数列表的==，当编译到函数调用点时，根据函数名字和传入的实参（个数和类型），和某一个函数重载匹配的话，就直接调用相应的函数重载版本（静态多态，编译阶段处理的）

## map底层实现，avl和rbtree有什么区别

map底层：红黑树

avl：平衡树二叉树，每一个结点的子树的高度差绝对值不会大于1，所以增删查效率很好，但是为了维护平衡，引入了四种旋转，旋转次数过多会使效率下降，所以在数据量大的时候，增删查效率就降下来了

> 在百万级数据以上可以体现出红黑树的效率，在百万级以下，红黑树效率并不一定就比avl高

rbtree：不是一颗平衡树，红黑树只有左旋右旋两种旋转，数据量大的时候效率比avl树好

## 假如map的键是类类型，那么map的底层是如何调整的

map底层是红黑树，map存的是[key, value]，是需要对key进行比较的，如果键是类类型，要给类提供<运算符的重载函数

## 内存泄漏你会怎么处理

怎么定位内存泄漏的问题？通过工具进行检测，vs里面可以使用vld工具来检测内存泄漏

## 如果让你实现一个内存池，要求获取资源和插入资源时间花费O(1)，你会怎么设计？

仿照SGI STL二级空间配置器的内存池的实现就可以了

## 如果构造函数里面抛出异常会发生什么？内存泄漏？怎么解决？

构造函数里面抛出异常会使得对象没有构造成功，那么就不会调用析构函数，如果构造函数里面抛出异常之前有动态开辟空间，而因为没有调用析构函数，==析构函数里面的delete语句得不到执行，就会造成内存泄漏==，如下代码：

```cpp
class Test
{
public:
	Test()
	{
		p1 = new int;
		p2 = new int;
		throw "xxxx";
	} 
    ~Test()
	{
		delete p1;
		delete p2;
	}
private:
	int *p1;
    int *p2;
};
Test t;
```

解决办法：使用智能指针

```cpp
class Test
{
public:
	Test()
	{
		p1 = new int;
		p2 = new int;
		throw "xxxx";
	} 
    ~Test()
	{ }
private:
	unique_ptr<int> p1;
	unique_ptr<int> p2;
};
Test t;
```



